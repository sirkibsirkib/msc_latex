\chapter{Introduction}	


Traditional, sequential programming has been changing for decades. Over time, languages acquired more and more tools to manage the level of abstraction, such that programs were of higher quality, and with a lower cost to develop~\cite{shaw1984abstraction}. This trend continues to this day. For example, conventionally imperative languages such as Java and C++ have since added functional features, such as closures, to capitalize on their brevity and lack of side-effects. Concurrent programming has undergone a similar process. Various paradigms have emerged to offer their own solutions to managing abstraction. \textit{Coordination languages} attempt to reduce the coupling between the logical coordination of a program from its implementation. Their namesake is their efforts to isolate that which makes concurrency distinct from sequential programming: the coordination of actions into \textit{interactions}. The means by which this is achieved varies. Linda is a well-known example of a coordination language which abstracts away the \textit{implementation} of coordination actions. Programs are written in terms of read and write operations over a global name-space of \textit{tuple} variables. In this manner, coordination actions occupy a higher level of abstraction, and are thus more terse, simple and re-usable~\cite{gelernter1985generative}.


Reo is a coordination language developed at the CWI in Amsterdam. As with Linda, Reo augments another general purpose programming language by allowing a more abstract expression of coordination. Unlike Linda, Reo facilitates the `extraction' of a program's coordination logic to a self-contained \textit{protocol specification}. Reo does away with action-centricism; protocols constrain the ways in which data is permitted to \textit{flow} through a system of graphical nodes, ie.\ protocols define their permitted \textit{interactions}~\cite{arbab2005abstract}. The specification is translated by the \textit{Reo compiler} to a the target language. The result is a \textit{protocol object}, which acts as a coordination medium for the system's actors by distributing a set of \textit{ports} through which they are able to send and receive data. In programming these actors, one is able to rely on the protocol object to coordinate port actions such that the system at large adheres to the protocol specification at runtime. Effectively, programmers are able to act on ports without making any assumptions about the environment beyond.

%In this work, we focus on Reo's use in \textit{code generation}. Instead of intertwining coordination and computation, programmers write a compute-oriented codebase in their language of choice, where each component communicates with its environment through opaque port-objects. Separately, programmers define a protocol which governs how these ports communicate. The \textit{Reo compiler} generates the action-centric glue code as if they programmer had written it themselves, with the guarantee that it behaves as specified~\cite{jongmans2013modularizing}. In this manner, programmers are able to understand and manipulate their code given the best of both worlds: a high-level view into abstract and modular components, while compiled and executed using the language of their choice. Over time, the Reo compiler has been extended to support various compilation-target languages, with Java seeing the most extensive development. 

In this work, we aim to extend the Reo compiler and its related tooling such that it can be integrated into the development pipelines of programs in systems-languages such as C, C++ and Rust. Chapter~\ref{sec:imperative_form} details the development of a Rust-language target for the Reo compiler, whose outputs are inter-operable with these languages. We discuss the various representation changes that a Reo protocol specification must undergo before valid Rust can be emitted.

Reo has intuitive \textit{value-passing} semantics, such that data moving through ports is transferred in its entirety, without interference from the actions of other ports. In the realm of shared memory, this has an undesirable na\"ive implementation which must move the contents of large data-types repeatedly. Reo-compiled Java code makes use of an optimization whereby values are kept in place, and their \textit{references} are moved through ports instead. Currently, Reo-generated Java protocol objects are circumstantially subject to \textit{data races} as a result of applying this optimization. This violates Reo's semantics; actors cannot be certain that a value acquired through a local port is not being accessed by someone else concurrently. Chapter~\ref{sec:protocol_runtime} explains how our Reo-generated Rust combines the language's systems-level memory management with the explicit protocol descriptions of Reo to perform reference-passing and other optimizations such that Reo's semantics are preserved. Other 
optimizations are also explored. Chapter~\ref{sec:benchmarking} provides an evaluation of our implementation at runtime, comparing it to Reo-generated Java, hand-crafted Rust, and breaking down its performance in response to properties of the input Reo specification.

Reo's protocols specify which behaviors systems are and are not permitted to exhibit. At runtime, protocol objects organize actions on their boundary ports into permitted interactions. Actions do not succeed until they are permitted. In this manner, port actions at the wrong time will not cause the program to deviate from the protocol, but may cause a loss of program \textit{liveness} if the operation blocks for an interaction that never comes. For such cases, Chapter~\ref{sec:api} explores the design of \textit{static governors}, which allow the programmer to opt-into verifying that local actions will not impede program liveness.

\chapter{Introduction}	


Traditional, sequential programming has been changing for decades. Over time, languages acquired more and more tools to manage the level of abstraction, such that programs were of higher quality, and with a lower cost to develop~\cite{shaw1984abstraction}. This trend continues to this day. For example, conventionally imperative languages such as Java and C++ have since added functional features, such as closures, to capitalize on their brevity and lack of side-effects. Concurrent programming has undergone a similar process. Various paradigms have emerged to offer their own solutions to managing abstraction. \textit{Coordination languages} attempt to reduce the coupling between the logical coordination of a program from its implementation. Their namesake is their efforts to isolate that which makes concurrency distinct from sequential programming: the coordination between concurrent components. The means by which this is achieved varies. Linda is a well-known example of a coordination language which abstracts away the \textit{implementation} of coordination actions. Programs are written in terms of read and write operations over a global name-space of \textit{tuple} variables. In this manner, coordination actions occupy a higher level of abstraction, and are thus more terse, simple and re-usable~\cite{gelernter1985generative}.

%Reo is an exogenous coordination language developed at the CWI in Amsterdam. A Reo specification defines a \textit{connector}, which 

Reo is an exogenous coordination language developed at the CWI in Amsterdam. Like Linda, Reo raises the level of abstraction in coordination actions by restricting the interface between distinct system \textit{components}. Rather than actions on \textit{tuples} in a global scope, Reo components act on local \textit{ports}. Reo differs from Linda by avoiding a vestige of the connection to the world of sequential programming: \textit{action-centricism}. The traditional approach of making explicit each actor's actions and \textit{deriving} the interactions is turned on its head. The implementation of coordinated components is agnostic to the system beyond their local ports, only acting in accordance with their local computation. Systems are built by linking these components together by specifying their relationship in a Reo \textit{connector}. The Reo language defines the ways in which ports are permitted to \textit{interact}. 

Separately, components are linked together by specifying a \textit{connector} in the Reo language, constraining permitted interactions by enumerating \textit{relations} between ports. When used in this

Reo components are oblivious to the system beyond, and thus, only act in accordance with the needs of their local computation, sending and receiving data through their ports. 


 Components act on their local ports oblivious to the system beyond, sending and receiving data in accordance with their computation. Separately, a 
Reo is \textit{exogenous}

Reo specifies the accepted behavior of a program by constraining the \textit{interactions} that relate distinct \textit{components}, from which the granular actions can be derived~\cite{arbab2011puff}. Components share data by exchanging messages at their shared \textit{ports}. In this manner, each port is oblivious to the environment beyond its ports. Reo is also 


Reo programs are conceptualized as compositions of weakly-coupled \textit{components}, communicating through \textit{ports}. The language specifies the 
Unlike Linda, these actions occur in a \textit{local} scope, and make no assumptions about their environment other than the data-type. With all these components in place, the Reo language can specify how data is permitted to `flow' between ports using dense, self-contained, and declarative~\cite{arbab2004reo}. By separating the code for computation and coordination in this manner, Reo is said to be \textit{exogenous}. With this approach, protocols and compute-components become swappable, re-usable modules; each can be more easily understood, maintained and re-used. The Reo language is designed such that the protocols behave as expected when \textit{composed}; one can reason about components in isolation, safe in the knowledge that their properties are preserved in the system at large. An ecosystem of tooling has sprung up around the Reo language to make use of these explicit protocol specifications, ranging from visualization to verification. 

In this work, we focus on Reo's use in \textit{code generation}. Instead of intertwining coordination and computation, programmers write a compute-oriented codebase in their language of choice, where each component communicates with its environment through opaque port-objects. Separately, programmers define a protocol which governs how these ports communicate. The \textit{Reo compiler} generates the action-centric glue code as if they programmer had written it themselves, with the guarantee that it behaves as specified~\cite{jongmans2013modularizing}. In this manner, programmers are able to understand and manipulate their code given the best of both worlds: a high-level view into abstract and modular components, while compiled and executed using the language of their choice. Over time, the Reo compiler has been extended to support various compilation-target languages, with Java seeing the most extensive development. 

In this work, we aim to extend the Reo compiler and its related tooling such that it can be integrated into the development pipelines of programs in systems-languages such as C, C++ and Rust. Chapter~\ref{sec:imperative_form} details the development of a Rust-language target for the Reo compiler, whose outputs are inter-operable with these languages. We discuss the various representation changes that a Reo protocol must undergo before valid Rust can be emitted.

Reo has intuitive \textit{value-passing} semantics, such that data moving from one component to another is logically transferred in its entirety, without interference from the actions of other ports. In the realm of shared memory, this has an undesirable na\"ive implementation which must move the contents of large data-types repeatedly. Reo-compiled Java code makes use of an optimization whereby values are kept in place, and their \textit{references} are moved through ports instead. Currently, Reo-generated Java are circumstantially subject to \textit{data races} as a result of applying this optimization, resulting in behavior that conflicts with Reo's semantics. As a result, compute-components cannot be certain that their values are not being accessed by other components. Chapter~\ref{sec:protocol_runtime} explains how our Reo-generated Rust combines the language's systems-level memory management with the explicit protocol descriptions of Reo to perform reference-passing and other optimizations such that Reo's semantics are preserved. Chapter~\ref{sec:benchmarking} provides an evaluation of our implementation at runtime, comparing it to Reo-generated Java, hand-crafted Rust, and breaking down its performance in response to properties of its input specification.

Reo's protocols specify which behavior a system is about to exhibit, and thereby prohibiting all else. If compute-components attempt to perform actions which do not adhere to the protocol, they are simply not paired with an enabling interaction by the protocol object at runtime. Programs can rely on Reo to preserve safety properties in this manner. However, it is not always ergonomic for compute-components to know which actions are \textit{protocol adherent}. In this context, deviations lead to a loss of \textit{liveness}, as compute components wait for actions which never complete. Chapter~\ref{sec:api} describes the development of mechanism for compute-components to verify that their behavior is protocol-adherent at \textit{compile time}. Deviations are detected as early as possible, and do not incur overhead at runtime. These checks do not require the use of additional tooling; they rely on the type-checking process of the Rust compiler itself, by projecting the protocol's behavior into Rust's type system.

\chapter{Introduction}
\hl{
(TODO)
abstractions are everywhere in programming but coordination is still primitive.
there is a large gap between protocol concept and implementation. makes code confusing, hard to maintain, brittle, buggy, and non-standardized.
we wish to solve this problem by expressing the protocol at a higher level of abstraction and then compile down to something efficient.
Reo is a language well-suited for this task. it is very expressive, you can describe relations between data visible at ports. can express state etc.
the semantics for reo are value-passing; this is natural for composability and modularity.
In the context of shared memory, the java backend is performant owing to its reliance on semantic value-passing, implemented by passing object references `under the hood'. Currently, this implementation is not entirely correct; mutable datatypes are subject to data races for connectors which replicate data.
there are incentives for adding support for systems languages such as C: they represent a large swathe of the possible user space, and their low-levelness means that they can more effectively leverage the information that protocol descriptions provide in the first place.
Rust is a programming language similar to C++, and intended for a similar audience. aside from the comforts of modern programming languages (closures, generics, functional patterns, extensive macros) it is notable for its unique memory management system: it relies on affine types to statically manage variable bindings, implicitly freeing memory which goes out of scope in a predictible manner. its ownership rules also prevent the majority of data races and protect the programmer from undefined behavior such as accessing uninitialiedd memroy. its UNSAFE sub-language is very similar to C, and can be tapped-into explicitly to achieve optimizations that the compiler cannot prove are safe. Rust is also useful for its exceptionally expressive APIs, as the types themselves allow and require the OWNERSHIP of values to be specified, giving the callee more freedom to specialize their bejhavior according to these guarantees. 
in this work we detail the development of a Rust back-end for the Reo compiler to generate protocol objects which can act as the communication mediums of `compute components'.
furthermore, we explore how we are able to leverage the affine type system of the Rust language to provide liveness properties to our coordinating programs.
}

Chapter~\ref{sec:background} introduces background information pertinent to Reo and our compile-target languages. Chapter~\ref{sec:imperative_form} explains how our new Reo back-end compiles to the Rust language via a new intermediate representation. Chapter~\ref{sec:protocol_runtime} describes our Reo-rs library which gives the Reo-generated code its runtime behavior as a coordination medium. Chapter~\ref{sec:api} describes our orthogonal tool for statically checking protocol adherence to protocols at runtime. Chapter~\ref{sec:benchmarking} evaluates the runtime performance of our protocol objects, offering comparisons to Reo's other back-ends, to hand-crafted coordination code, and exploring how the protocol's description influences runtime. Finally, Section~\ref{sec:discussion} reflects on our contributions as a whole and highlights opportunities for future work.


\chapter{Introduction}	


Traditional, sequential programming has been changing for decades. Over time, languages acquired more and more tools to manage the level of abstraction, such that programs were of higher quality, and with a lower cost to develop~\cite{shaw1984abstraction}. This trend continues to this day. For example, conventionally imperative languages such as Java and C++ have since added functional features, such as closures, to capitalize on their brevity and lack of side-effects. Concurrent programming has undergone a similar process. Various paradigms have emerged to offer their own solutions to managing abstraction. \textit{Coordination languages} attempt to reduce the coupling between the logical coordination of a program from its implementation. Their namesake is their attempt to isolate that which makes concurrency distinct from sequential programming: the coordination between concurrent components. The means by which this is achieved varies. Linda is a well-known example of a coordination language which abstracts away the \textit{implementation} of coordination actions. Programs are written in terms of read and write operations over a global name-space of \textit{tuple} variables. In this manner, the coordination operates at a higher level of abstraction, and thus become more terse, simple and re-usable~\cite{gelernter1985generative}.

Reo is an exogenous coordination language developed at the CWI in Amsterdam. It shares several features with Linda, but attempts to remove a vestige of the connection to the world of sequential programming: \textit{action-centricism} ie.\ making explicit the individual actions contributing to interactions, rather than the interactions themselves~\cite{arbab2011puff}. Reo programs are conceptualized as compositions of weakly-coupled \textit{components}, communicating through \textit{ports}. Unlike Linda, these actions occur in a \textit{local} scope, and make no assumptions about their environment other than the data-type. With all these components in place, the Reo language can specify how data is permitted to `flow' between ports using dense, self-contained, and declarative~\cite{arbab2004reo}. By separating the code for computation and coordination in this manner, Reo is said to be \textit{exogenous}. With this approach, protocols and compute-components become swappable, re-usable modules; each can be more easily understood, maintained and re-used. The Reo language is designed such that the protocols behave as expected when \textit{composed}; one can reason about components in isolation, safe in the knowledge that their properties are preserved in the system at large. An ecosystem of tooling has sprung up around the Reo language to make use of these explicit protocol specifications, ranging from visualization to verification. 

In this work, we focus on Reo's use in \textit{code generation}. Instead of intertwining coordination and computation, programmers write a compute-oriented codebase in their language of choice, where each component communicates with its environment through opaque port-objects. Separately, programmers define a protocol which governs how these ports communicate. The \textit{Reo compiler} generates the action-centric glue code as if they programmer had written it themselves, with the guarantee that it behaves as specified~\cite{jongmans2013modularizing}. In this manner, programmers are able to understand and manipulate their code given the best of both worlds: a high-level view into abstract and modular components, while compiled and executed using the language of their choice. Over time, the Reo compiler has been extended to support various compilation-target languages, with Java seeing the most extensive development. 

In this work, we aim to extend the Reo compiler and its related tooling such that it can be integrated into the development pipelines of programs in systems-languages such as C, C++ and Rust. Chapter~\ref{sec:imperative_form} details the development of a Rust-language target for the Reo compiler, whose outputs are inter-operable with these languages. We discuss the various representation changes that a Reo protocol must undergo before valid Rust can be emitted.

Reo has intuitive \textit{value-passing} semantics, such that data moving from one component to another is logically transferred in its entirety, without interference from the actions of other ports. In the realm of shared memory, this has an undesirable na\"ive implementation which must move the contents of large data-types repeatedly. Reo-compiled Java code makes use of an optimization whereby values are kept in place, and their \textit{references} are moved through ports instead. Currently, Reo-generated Java are circumstantially subject to \textit{data races} as a result of applying this optimization, resulting in behavior that conflicts with Reo's semantics. As a result, compute-components cannot be certain that their values are not being accessed by other components. Chapter~\ref{sec:protocol_runtime} explains how our Reo-generated Rust combines the language's systems-level memory management with the explicit protocol descriptions of Reo to perform reference-passing and other optimizations such that Reo's semantics are preserved. Chapter~\ref{sec:benchmarking} provides an evaluation of our implementation at runtime, comparing it both to the Java analog, and to hand-crafted Rust programs.

Reo's protocols specify which behavior a system is about to exhibit, and thereby prohibiting all else. If compute-components attempt to perform actions which do not adhere to the protocol, they are simply not paired with an enabling interaction by the protocol object at runtime. Programs can rely on Reo to preserve safety properties in this manner. However, it is not always ergonomic for compute-components to know which actions are \textit{protocol adherent}. In this context, deviations lead to a loss of \textit{liveness}, as compute components wait for actions which never complete. Chapter~\ref{sec:api} describes the development of mechanism for compute-components to verify that their behavior is protocol-adherent at \textit{compile time}. Deviations are detected as early as possible, and do not incur overhead at runtime. These checks do not require the use of additional tooling; they rely on the type-checking process of the Rust compiler itself, by projecting the protocol's behavior into Rust's type system.

%In this work, we extend the Reo compiler's repertoire of supported language targets by designing and implementing a Rust back-end. Rust is a favorable choice, as it is easily inter-operable with C and C++, making the Reo compiler accessible to the large audience. Furthermore, Rust has a strict type system that allows us to expose an API that guarantees conformance with Reo's intuitive value-passing semantics. Chapter~\ref{sec:imperative_form} describes how this translation is performed. Chapter~\ref{sec:protocol_runtime} explains how we are able to leverage Reo's explicit protocols in combination with Rust's systems-level resource management to safely implement various optimizations. In particular we facilitate the movement of data \textit{by reference} between ports in shared memory, reducing the cost of exchanging large data structures without 
% such as transparent \textit{reference-passing} for components coordinating in shared-memory. Chapter~\ref{sec:api} investigates leveraging Rust's \textit{affine type system} to offer an ergonomic mechanism to inject \textit{liveness properties} of our Reo-coordinated Rust programs by checking our compute-code for \textit{protocol adherence} at compile-time without significant overhead at run-time.


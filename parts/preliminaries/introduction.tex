\chapter{Introduction}	


Traditional, sequential programming has been changing for decades. Over time, languages acquired more and more tools to manage the level of abstraction, such that programs were of higher quality, and with a lower cost to develop~\cite{shaw1984abstraction}. This trend continues to this day. For example, conventionally imperative languages such as Java and C++ have since added functional features, such as closures, to capitalize on their brevity and lack of side effects. Concurrent programming has undergone a similar process. Various paradigms have emerged to offer their own solutions to managing abstraction. \textit{Coordination languages} attempt to reduce the coupling between the logical coordination of a program, and its implementation. They work by isolating that which makes concurrency distinct from sequential programming: the coordination of actions into interactions. The means by which this is achieved varies. Linda is a well-known example of a coordination language which abstracts away the implementation of coordination actions. Programs are written in terms of read and write operations over a global namespace of tuple variables. In this manner, coordination actions occupy a higher level of abstraction, and are thus more terse, simple and reusable~\cite{gelernter1985generative}.


Reo is a coordination language developed at the CWI in Amsterdam. As with Linda, Reo is able to augment another general-purpose programming language by allowing a more abstract expression of coordination. Unlike Linda, Reo facilitates the `extraction' of a program's coordination logic to a self-contained \textit{protocol specification}. Reo does away with action-centricism; protocols constrain the ways in which data is permitted to flow through a system of graphical nodes, i.e.,\ protocols define their permitted interactions~\cite{arbab2005abstract}. The specification is translated by the Reo compiler to a the target language. The result is a \textit{protocol object}, a data structure which acts as a coordination medium for the system's actors. At runtime, components send and receive data through \textit{ports} managed by the protocol. Components can rely on the protocol to coordinate their actions such that the system at large behaves as specified. 

In this work, we aim to extend the Reo compiler and its related tooling such that it can be integrated into the development pipelines of programs in systems languages such as C, C++ and Rust. Chapter~\ref{sec:imperative_form} details the development of a Rust language target for the Reo compiler, whose outputs are interoperable with these languages. We discuss the various representation changes that a Reo protocol specification must undergo before valid Rust can be emitted.

Reo has intuitive \textit{value-passing} semantics, such that data moving through ports is transferred in its entirety, without interference from the actions of other ports. In the realm of shared memory, this has an undesirable na\"ive implementation which must move the contents of large values repeatedly. Reo-generated Java code makes use of an optimization whereby values are kept in place, and their references are moved through ports instead. Currently, these Java programs are circumstantially subject to data races as a result of applying this optimization. This violates Reo's semantics; actors cannot be certain that a value acquired through a local port is not being accessed by someone else concurrently. Chapter~\ref{sec:protocol_runtime} explains how our Reo-generated Rust combines the language's systems-level memory management with the explicit protocol descriptions of Reo to perform reference-passing such that Reo's semantics are preserved. Other 
optimizations are also explored. Chapter~\ref{sec:benchmarking} provides an evaluation of our implementation at runtime, comparing it to Reo-generated Java, handcrafted Rust, and breaking down its performance in response to properties of the input Reo specification.

Reo's protocols specify which behaviors systems are and are not permitted to exhibit. At runtime, protocol objects organize actions on their boundary ports into permitted interactions. Actions do not succeed until they are permitted. In this manner, port actions at the wrong time will not cause the program to deviate from the protocol, but may cause a loss of program liveness if the operation blocks, waiting for an interaction that never comes. For such cases, Chapter~\ref{sec:api} explores the design of \textit{governors}, structures which allow the programmer to statically verify that local actions will not impede program liveness.

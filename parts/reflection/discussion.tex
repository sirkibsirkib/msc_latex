\chapter{Discussion}
\label{sec:discussion}
\section{Future Work}
\hl{TODO short intro}
\subsection{Imperative Form Compiler}
Chapters~\ref{sec:imperative_form} and~\ref{sec:protocol_runtime} explain how the Reo-rs runtime makes use of a lightweight interpreter to bring life to our protocol objects at runtime according to the appropriate specification. This \textit{commandification} pattern has its advantages; namely, protocol behavior is alterable at runtime by manipulating the interpreted data. However, this flexibility does not come for free. The interpretation steps incur overhead both to the protocol construction procedure, and more importantly, to the work of \textit{port operations}. Fortunately, our \textit{imperative form} does not necessitate the use of an interpreter. Future work could investigate replacing the \code{build} procedure of Reo-rs with another compilation step such that the behavior is represented in native, directly-executable Rust. 

Futhermore, future work might investigate the use of custom \textit{domain specific languages} for compiling imperative form in a manner that it performs the same checking as in \code{build} \textit{statically}. the obvious means of doing this is to build a compiler from scratch. However, other options exist that can make better use of existing tools. For example, Rust's \textit{procedural macros} allow the programmer to define arbitrary transformations of Rust's \textit{abstract syntax trees} during compilation. Essentially, one is able to invoke arbitrary, pre-compiled Rust code \textit{inside} the user's Rust compiler itself. In this manner, one can embed the needed domain-specific language into the Rust compiler itself.

\subsection{Distributed Components}
\hl{TODO refer to Reowolf. talk about how protocols can become distributed by partitioning their memory space. problem is complex. involves consensus. refer to reowolf project. refer to farhad's and sung's previous work}
\subsection{Imperative Branching}
\hl{as propositional formulas can be converted to DNF (with disjunctions on the outermost layer), so too can imperative form rules be split over OR branches into new rules (EXAMPLE). This idea can be taken to the extreme: splitting over the elements of the data domain and once again enumerating the transition space, resulting in something with the most degenerate RBAs possible with an explosion in rules. In some cases, moving in this direction is desirable, as it has the effect of making the rule GUARDS do all of the checking; as seen earlier, boolean guarded variables can be efficiently checked in bulk. THe extreme of the spectrum is unlikely to be more efficient: the same transform values will be computed and discarded repeatedly, and as the number of boolean variables increases, at some point even batch-computing them falls behind. Future work could investigate this balance between a small number of rules, and determinisms in rules.}
\subsection{Runtime Governors}
\hl{TODO}
more abstract suggestion. runtime governers. makes it possible to use them without affine types. eg in C

\subsection{Further Runtime Optimization}
\hl{Didn't implement everything for variious reasosn but lots is possible}
\begin{enumerate}
	\item simplify or remove predicates based on implicit information if rules have a KNOWN ordering. EG:: before [if P, if not P]. after [if P, true]
	\item stuffed pointers for data types with representations no larger than ptr size. no need for allocator. complicates the refcounter mechanism
	\item imperative form preprocessing. some redundancy exists in how you can represent things. eg: MemSwap sometimes can be achieed just by reorganizing your movements. more examples: pruning check subtries of tautologies and contradictions. this can happen in either reo or reo-rs
\end{enumerate}
\subsection{Avoid Lock Re-Entry}
\hl{when you empty a memcell you need to coordinate again. would be nice if we can avoid locking a second time by either detecting when we know it will be unnecessary or just some mechanism to delegate the work}
\subsection{Runtime Reconfiguration}
\hl{our protocol is data. we can change it and change its behavior. care must be taken because you are reconfiguring the structure laid out for speed}
\section{Conclusion}
\hl{TODO}
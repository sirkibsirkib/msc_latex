\chapter{Code Generation}
\label{sec:imperative_form}







\section{Two-Phase Code Generation}
In this section, we motivate our choice of segmenting the code generation process into two distinct phases. Throughout, we refer to the precedent set by the existing Reo compiler backend for generating code in the Java language, as it has seen the language most similar to Rust which has seen significant development.

TODO

\subsection{Generation Sub-tasks}
Reo specifications represent connectors declaratively as relations between ports. They are thus well-suited to reasoning about the protocol's properties. In contrast, our target imperative languages such as Java and Rust represent computation such that it corresponds more closely to machine instructions; they are imperative, laying out sequences of actions which together emerge as interaction at runtime. Where interactions in the former can be oriented around the synchronous observations of port values, interactions of the latter must be expressed as sequences of actions, laid out over time. To facilitate these new, explicit orderings, \textit{temporary variables} must be introduced to avoid race conditions without overwriting values at the wrong time. If done incorrectly, the resulting imperative program may not behave as expected, ie.\ with users observing stale valuesas the result of subtle race conditions. Even if the translation is otherwise correct, the generated code may be invalid if care is not taken to render the output in according to the target's \textit{syntax}. 

Rust and Java have in common their strongly-typed language, while Reo is untyped. To facilitate the desired level of specificity for connectors, the \textit{textual Reo} language has support for optional \textit{data type annotations} on ports, which are retained by the Reo compiler for use by the relevant backend. How these annotations are used is not specified, as their interpretation is only sensible for target languages in a case-by-case basis. To us, these annotations are understood as types which the associated ports must be capable of transmitting. For our typed languages, typing information must be injected such that the emitted target code is valid.

Regardless of the intermediate representation, protocol objects must ultimately be emitted in the target language. Aside from expression in the correct syntax, the end result must make explicit any work required to make it \textit{executable} with the desired runtime behavior. Even simple concepts require the support of auxiliary book-keeping structures to maintain the protocol object's state, and specialized \textit{concurrency primitives} are needed to ensure that actions compose into interactions at runtime in the expected way. Clearly, this is very particular to the target language, as they vary greatly on how they fundamentally express operations on data at a granular level.

In summary, we identify three sub-tasks of generating target language protcol objects from a Reo protocol description:
\begin{itemize}
	\item [$T_{act}$] Synchronous interactions must be decomposed into asynchronous actions, with the roles of each participant laid out in a sequence.
	\item [$T_{type}$] Ports must be given data types such that they agree with any (optional) type-annotations in the Reo specification, and successfully type-check in the target language.
	\item [$T_{run}$] Details necessary to make the result runnable are included. Symbolic actions are represented as concrete operations on data.
\end{itemize}


\subsection{Decoupling the Reo Compiler from Rust}
The Reo compiler has an existing backend for generating Java code. It works by generating Java according to the structure of a \textit{template generator}. In this manner, it can be thought of as performing all code-generation sub-tasks at the same time directly from the compiler's intermediate representation. However, the extent to which the Reo compiler is \textit{coupled} to the Java language is reduced through the reliance on a Java library for the granular implementations of structures that are common to all protocol objects; rather than generating these classes each time, the Reo compiler simply generates a dependency. For example, the library defines a \code{Component} interface, for which the code generator produces a protocol-specific implementor class. Consequently, a significant part of $T_{run}$ is delegated to this library.

For $T_{type}$, help comes from the Reo compiler itself, which in its current form was developed with support for Java in mind. This can be seen in the structure of its internal representation. For example, types are given a \textit{default} type in the event the input specification omits a type-annotation; this is no trouble for Java, which can up-cast all classes to~\code{Object} without losing the capabilities on which the protocol relies at runtime, namely (1) equality checks, and (2) object replication\footnote{In the chapter to follow, we discuss the consequence of this approach, as it necessarily assumes that operations for checking equality and replication can be resolved for any types.}.

Only $T_{act}$ is performed almost entirely by the template generator. For simple protocols, this task is relatively easy, as there is not much to add when actions are largely concurrent. For example, replicating the contents of a memory cell into a new one is simply-done in Java, reading and then overwriting object references. However, ordering dependencies must be resolved very carefully in the general case. The current Java code generator is susceptible to erroneously emitting value~$b$ in the event that the memory cell containing~$b$ synchronously overwrites~$a$ with~$b$. Even with the help of the template generator, this translation is sufficiently complex to make detection of these bugs difficult.

Rust is able to mimic Java's approach to create a similar backend through the explicit use of \textit{dynamic dispatch}, such that types can be collapsed to something analogous to Java's \code{Object} class. If done na\"ively, the resulting backend would inherit the problems of its predecessor, and new ones to boot; the Java-like approach is not idiomatic in the context of Rust, and it would not make good use of the extensive control of systems resources unique to a systems language. Chapter~\ref{sec:protocol_runtime} to follow goes into detail about the properties of the protocol runtime. Here, it suffices to say that we wish to implement a runtime that does not rely on heap-allocation of its port-values, and thus cannot rely entirely on dynamic dispatch. Furthermore, our runtime wishes to perform more extensive optimizations, relying on the unique abilities of our systems language to manipulate its resources at a low level. All these extensions pose a problem in particular for $T_{run}$, as runtime properties directly influence how the executable protocol objects are represented. Our work in unremarkable in its solution to this problem: we delegate~$T_{act}$ to a Rust library. However, we make this separation more extreme. In a nutshell, we wish to partition the work of code generation into two clear \textit{phases}, the former of which performs tasks~$T_{seq}$ and~$T_{type}$, and the latter of which performs $T_{act}$. To minimize coupling, the interface between these phases is made terse and explicit in the definition of a new intermediate representation of protocol connectors: the \textit{imperative form}.

\subsection{Temporary Simplifications}
Our intention is to isolate the Reo backend from Rust's specifics as extensively as possible. In this manner, we decouple the modules responsible for the code-generation subtasks in accordance with good software engineering practices. Furthermore, it facilitates the \textit{re-use} of the first phase of the code generation process for \textit{other} imperative programming language targets. The section to follow defines imperative form to be as target-language agnostic as possible. However, for the sake of minimizing the disturbance to the Reo tooling ecosystem, we still embrace the per-target structure for Reo code generation for now. As such, the Reo compiler still specifies a Rust language target, and emits executable Rust source as a result. For now, our representation of the \textit{imperative form} is expressed in Rust syntax (as the \code{ProtoDef} type) such that this reliance on an intermediate representation is invisible to the end user. As far as they are concerned, Reo generates native Rust that just happens to \textit{somehow} make minimal use of Rust-specific syntax. For the sake of future work, \code{ProtoDef} maps adheres to our conceptual definition for imperative form as closely as possible.


\section{Imperative Form}
In this section, we define our new intermediate representation of Reo protocol specifications. We include an intuitive look at how it captures the details of the Reo compiler's internal representation, but such that only $T_{act}$ remains to be performed before the finished Rust source code can be emitted.


\subsection{Intuition}
Imperative form makes explicit the \textit{ordering} of events for which the ordering cannot be arbitrary. In other words, synchronous concurrency can still be expressed, but operations whose correctness relies upon their ordering are expressed explicitly. For very simple protocols, imperative form is very similar to their original relational representation, notably excepting the distinction between \textit{guard} and \textit{assignment}. This separation is not unique to imperative form, and is already provided by the Reo compiler's internal representation as input to the code generator. Within the guard, only unordered structures are used; for example, the \textit{synchronization constraint} is represented as a \textit{set} of ports.

Imperative form differs from that of the compiler's intermediate representation the more extensively the protocol makes use of synchronous manipulations of its state, ie.\ the more the protocol's state is mutated \textit{within} a single rule. For example, a protocol in RBF with rule $f(P_0)=f(P_1)=f(P_2)$ with input (putter) ports $P_{0-2}$ is represented very differently indeed; in this example, the results of $f$ clearly cannot be compared until \textit{after} they are computed.

As an approachable metaphor, imperative form represents a synchronous rule firing as a \textit{transaction} by structuring its actions and partitioning the sequence around some instant where the rule can be said to \textit{commit}. Actions then fall into one of two categories:
\begin{itemize}
	\item \textbf{Transient Actions}\\
	Actions \textit{before} committing may only perform mutations of the protocol state that can be \textit{rolled back} reversing their effects. Implicitly, this prohibits any actions that are visible to an outside observer. Actions are also allowed to trigger a rollback and abort.
	
	\item \textbf{Persistent Actions}\\
	Action \textit{after} committing may irrevocably mutate the state and produce observable effects, but may not trigger a rollback.
\end{itemize}

For our example RBF, the check for equality acts as a \textit{guard}, but its computation involves consuming the values put by $P_{0-2}$. In imperative form, $f$ is required to be a pure function which does not \textit{consume} the values of $P_{0-2}$ (eg.\ by reading them via immutable reference), and is invoked to produce three temporary variables. These can be checked for equality. If the check fails, all actions \textit{roll back}, discarding our temporary variables and aborting the rule firing. This corresponds to a guard that was not \textit{satisfied}. On the other hand, if the equality passes, the rule \textit{commits} and the values of $P_{0-2}$ are irrevocably consumed (and in this case, discarded). In this way, $P_{0-2}$ only observe their data being consumed if the rule fires.

\subsection{Definition}


\section{Code Generation Pipeline}
\section{Phase 1: Reo Compiler Backend}
1. does actions and types, but not symbols
2. function around protocol def to introduce generics with bounds and control mem initialization

\section{Phase 2: Rust Library}
2. does symbols, and performs some redundant checks for types and so on.